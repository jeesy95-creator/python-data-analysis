# 프로그래머스 Lv2 388353 - 지게차와 크레인

🔗 문제 링크  
https://school.programmers.co.kr/learn/courses/30/lessons/388353

---

## 문제 요약
n×m 창고에 컨테이너(대문자)가 배치되어 있다.  
요청(requests)을 순서대로 처리하며 컨테이너를 꺼낸다.

- 요청 길이 1 (예: "A") → **지게차**
  - 요청 순간 **접근 가능한** 해당 종류 컨테이너를 모두 꺼냄
  - 접근 가능: 4면 중 적어도 1면이 **창고 외부(바깥 공기)와 연결**
- 요청 길이 2 (예: "BB") → **크레인**
  - 해당 종류 컨테이너 **전체**를 꺼냄 (접근성 무관)

모든 요청을 처리한 후 남은 컨테이너 개수를 반환한다.

---

## 접근 아이디어
- 빈 칸을 `.`로 표현하며, 컨테이너가 제거되면 `.`가 된다.
- 지게차는 “외부 공기와 연결된 빈 공간(.)”을 통해 접근 가능한 컨테이너만 제거해야 한다.
  - 핵심: BFS/DFS는 **빈 칸(.)만 이동**한다.
  - 이동 중 만나는 인접 칸이 target이면 그 칸은 “접근 가능” → 제거 대상에 추가한다.
  - 컨테이너 칸은 통로가 아니므로 **target 칸으로 이동하면 안 된다.**
- 크레인은 target 문자를 전부 `.`로 바꾼다.

---

## 버전별 구현
- **v1 (원본/주의)**: target 칸을 큐에 넣는 방식 → 논리적으로 target을 통로처럼 다루는 문제가 생길 수 있음
- **v2 (수정 정답)**: BFS는 `.`만 이동, 인접한 target만 제거 대상으로 체크
- **v3 (추천)**: 바깥을 감싼 패딩(outside) BFS로 “외부 공기”를 더 직관적으로 모델링

---

## 배운 점
- “외부와 연결”은 곧 **외부 공기 영역을 BFS로 탐색**하는 문제로 바꿀 수 있다.
- BFS에서 어떤 칸을 “통로”로 보는지(이동 허용/불허)가 문제의 정답을 좌우한다.
- 패딩 기법(테두리를 한 겹 둘러 BFS 시작점 단순화)은 구현 실수를 줄인다.

---

## 시간 복잡도
- 한 번의 지게차 요청: BFS로 최대 O(nm)
- 요청 최대 100회 → O(100·nm) ≤ 100·2500 = 250,000 수준
- 크레인 요청: 전체 스캔 O(nm)
→ 전체적으로 제한 내에서 충분히 빠르다.
